#+options: ':t *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t
#+options: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:t e:t
#+options: email:nil expand-links:t f:t inline:t num:t p:nil pri:nil prop:nil
#+options: stat:t tags:t tasks:t tex:t timestamp:t title:t toc:t todo:t |:t
#+title: README
#+date: <2024-06-10 Mon>
#+author: chu the pup
#+email: chufilthymutt@gmail.com
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 29.3 (Org mode 9.7)
#+created: <2024-06-10 Mon>
#+cite_export: nil
* Build
#+name: build
#+begin_src sh :shebang #!/usr/bin/env sh :tangle ./build :results none
make ./
#+end_src
* Makefile
#+name: Makefile
#+begin_src makefile :tangle ./Makefile :session make :results none
##
# chu lisp
#
# @file
# @version 0.2

CXXFLAGS ?= -g -Wall -Wextra -Werror

step0_repl: src/step0_repl.cpp
	$(CXX) $(CXXFLAGS) -o step0_repl src/step0_repl.cpp

step1_read_print: src/step1_read_print.cpp
	$(CXX) $(CXXFLAGS) -o step1_read_print src/step1_read_print.cpp
# end
#+end_src

* Run
#+name: run
#+begin_src bash :shebang #!/bin/bash :tangle ./run
exec $(dirname $0)/${STEP:-stepA_mal} "${@}"
#+end_src

* The Reader Header
#+name: reader.hpp
#+begin_src cpp :tangle ./src/reader.hpp :results none
#pragma once
#include <iostream>
#include <optional>
#include <string>
#include <string_view>

#include "types.hpp"

class Tokenizer {
public:
  Tokenizer(string &input) : m_input{input} {}
  optional<string_view> next() {
    auto view = string_view(m_input);
    while (m_index < m_input.length()) {
      char c = m_input.at(m_index);
      switch (c) {
      case ' ':  // space
      case '\t': // tab
      case '\n': // new line
      case ',':  // comma
        break;
      case '~': {
        if (m_index + 1 < m_input.length() && m_input.at(m_index + 1) == '@') {
          return view.substr(m_index++, 2);
          return view.substr(m_index, 1);
        }
      }
      case '[':  // open bracket
      case ']':  // closed bracket
      case '{':  // open curly
      case '}':  // closed curly
      case '(':  // open paren
      case ')':  // closed paren
      case '\'': // single quote
      case '`':  // backtick
      case '^':  // caret
      case '@':
        return view.substr(m_index, 1);
      case '"': {
        size_t start = m_index;
        ++m_index;
        while (m_index < m_input.length()) {
          c = m_input.at(m_index);
          switch (c) {
          case '"':
            return view.substr(start, m_index - start);
          case '\\':
            ++m_index;
            break;
          }
          ++m_index;
        }
        // If no ending double quote to pair with first double quote,
        // return whatever is left & EOF.
        cout << "EOF\n";
        return view.substr(start, m_index - start);
      }
      case ';': {
        size_t start = m_index;
        while (m_index < m_input.length()) {
          c = m_input.at(m_index);
          if (c == '\n')
            break;
          ++m_index;
        }
        return view.substr(start, m_index - start);
      }
      default: {
        size_t start = m_index;
        bool done = false;
        while (!done && m_index < m_input.length()) {
          c = m_input.at(m_index);
          switch (c) {
          case ' ':  // space
          case '\t': // tab
          case '\n': // new line
          case '[':
          case ']':
          case '{':
          case '}':
          case '(':
          case ')':
          case '\'':
          case '"':
          case '`':
          case ',':
          case ';':
            done = true;
            break;
          default:
            ++m_index;
          }
        }
        return view.substr(start, m_index - start);
      }
      }
      ++m_index; // skip whitespace
    }
    return {}; // return nothing if no token (a.k.a. why 'optional<string_view>
               // next()...' is necessary).
  }

private:
  string &m_input;
  size_t m_index{ 0 };
};

class Reader {
public:
  Reader(std::vector<std::string_view> &tokens) : m_tokens{tokens} {}

  std::optional<std::string_view> next() {
    if (m_index < m_tokens.size())
      return m_tokens.at(m_index++);
    return {};
  }

  std::optional<std::string_view> peek() {
    if (m_index < m_tokens.size())
      return m_tokens.at(m_index++);
    return {};
  }

private:
  std::vector<std::string_view> &m_tok
  size_t m_index{0};
};

std::vector<std::string_view> tokenize(std::string &input)
#+end_src

#+RESULTS: reader.hpp

* The Types
#+begin_src cpp :tangle ./src/types.hpp :results none
#pragma once
class Value {
};
#+end_src
* The Reader
#+begin_src cpp :tangle ./src/reader.cpp :results none
#include "reader.hpp"

std::vector<std::string_view> tokenize(std::string) {
  Tokenizer tokenizer{input};
  std::vector<std::string_view> vector;
  while (auto token = tokenizer.next()) {
    vector.push_back(*token);
  }
  return vector;
}

Value *read_str(std::string &input) {
  auto tokens = autotokenize(input);
  Reader reader{tokens};
  return read_form(reader);
}

Value *read_list(std::string &input) {
  auto tokens = autotokenize(input);
  Reader reader{tokens};
  return read_list(reader);
}

Value *read_form(Reader &reader) {
  auto token = reader.peek();

  if (!token)
    return nullptr;
  switch (token[0]) {}
}
#+end_src

#+RESULTS:

* Step 0: REPL
#+name: step0_repl.cpp
#+begin_src cpp :tangle ./src/step0_repl.cpp :results none
#include "./../linenoise.hpp"
#include <iostream>
#include <string>
using namespace std;
using namespace linenoise;

string R(string s) { return s; }
string E(string s) { return s; }
string P(string s) { return s; }

string r(string s) {
  P(R(E(s)));
  return P(s);
}

int main() {
  const auto history_path = "history.txt";
  LoadHistory(history_path);
  string s;
  for (;;) {
    auto quit = Readline("user> ", s);
    AddHistory(s.c_str());
    if (quit) { // ctrl+d to quit
      break;
    }
    cout << r(s) << endl;
    cin.clear();
  }
  SaveHistory(history_path);
  return 0;
}
#+end_src

#+RESULTS: step0_repl.cpp

* Step 1: READ and PRINT
#+name: step1_read_print.cpp
#+begin_src cpp :tangle ./src/step1_read_print.cpp :results none
#include "./../linenoise.hpp"
#include "reader.hpp"
#include <iostream>
#include <string>
using namespace std;
using namespace linenoise;

string R(string s) { return s; }
string E(string s) { return s; }
string P(string s) { return s; }

string r(string s) {
  P(R(E(s)));
  return P(s);
}

int main() {
  const auto history_path = "history.txt";
  LoadHistory(history_path);
  string s;
  for (;;) {
    auto quit = Readline("user> ", s);
    AddHistory(s.c_str());
    if (quit) { // ctrl+d to quit
      break;
    }
    cout << r(s) << endl;
    cin.clear();
  }
  SaveHistory(history_path);
  return 0;
}
#+end_src
