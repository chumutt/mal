#+title: Readme
#+PROPERTY: header-args :tangle yes
#+auto_tangle: t
* Make
** Makefile

#+begin_src makefile :tangle Makefile
##
# chu lisp
#
# @file
# @version 0.3
CXXFLAGS ?= -std=c++17 -g -Wall -Wextra -Werror

build: step0_repl step1_read_print

clean: rm -f step0_repl step1_read_print # step2_eval step3_env step4_if_fn_do

step0_repl: src/step0_repl.cpp
	$(CXX) $(CXXFLAGS) -o $@ $^

step1_read_print: src/step1_read_print.cpp src/reader.cpp src/printer.cpp src/types.cpp
	$(CXX) $(CXXFLAGS) -o $@ $< src/reader.cpp src/printer.cpp src/types.cpp
# end
#+end_src
** Run Make and Test
#+begin_src sh :tangle run-make-and-test :shebang #!/usr/bin/env sh
make && cd ../../ && make "test^cpp^step1" && cd impls/cpp/
#+end_src

#+RESULTS:
| g++ | -std=c++17 | -g | -Wall | -Wextra | -Werror | -o | step0_repl       | step0_repl.cpp       |                |                 |               |
| g++ | -std=c++17 | -g | -Wall | -Wextra | -Werror | -o | step1_read_print | step1_read_print.cpp | reader.cpp | printer.cpp | types.cpp |

** Run Make and Launch
#+begin_src sh :tangle run-make-and-launch :shebang #!/usr/bin/env sh
make && ./step1_read_print.cpp
#+end_src

#+RESULTS:
: g++ -std=c++17 -g -Wall -Wextra -Werror -o step1_read_print step1_read_print.cpp reader.cpp src/printer.cpp src/types.cpp

* Run
#+begin_src sh :shebang #!/usr/bin/env bash :tangle run
exec $(dirname $0)/${STEP:-stepA_mal} "${@}"
#+end_src

* Line Editor
linenoise.hpp
* Types
#+begin_src c++ :tangle src/types.hpp
#pragma once

#include <cassert>
#include <functional>
#include <iostream>
#include <string>
#include <string_view>
#include <unordered_map>
#include <vector>

class ExceptionValue;
class FalseValue;
class FnValue;
class HashMapValue;
class IntegerValue;
class KeywordValue;
class ListValue;
class NilValue;
class StringValue;
class SymbolValue;
class TrueValue;
class VectorValue;

class Value {
public:
  enum class Type {
    Exception,
    False,
    Fn,
    HashMap,
    Integer,
    Keyword,
    List,
    Nil,
    String,
    Symbol,
    True,
    Vector,
  };

  virtual Type type() const = 0;
  virtual std::string inspect(bool print_readably = false) const = 0;

  virtual bool is_exception() const { return false; }
  virtual bool is_false() const { return false; }
  virtual bool is_integer() const { return false; }
  virtual bool is_keyword() const { return false; }
  virtual bool is_list() const { return false; }
  virtual bool is_listy() const { return false; }
  virtual bool is_nil() const { return false; }
  virtual bool is_symbol() const { return false; }
  virtual bool is_string() const { return false; }
  virtual bool is_true() const { return false; }

  virtual bool operator==(const Value *other) const { return this == other; }
  bool operator!=(const Value *other) const { return !(*this == other); }

  ExceptionValue *as_exception();

  const ExceptionValue *as_exception() const;
};

class ListValue : public Value {
public:
  ListValue() {}

  void push(Value *value) { m_list.push_back(value); }

  virtual Type type() const override { return Type::List; }
  virtual std::string inspect(bool print_readably = false) const override;

  virtual bool is_list() const override { return true; }
  virtual bool is_listy() const override { return true; }

  virtual bool operator==(const Value *) const override;

  auto begin() { return m_list.begin(); }
  auto end() { return m_list.end(); }

  bool is_empty() const { return m_list.size() == 0; }
  size_t size() const { return m_list.size(); }
  Value *at(size_t index) const { return m_list.at(index); }

protected:
  std::vector<Value *> m_list{};
};

class VectorValue : public ListValue {
public:
  VectorValue(){};

  virtual Type type() const override { return Type::Vector; }
  virtual std::string inspect(bool print_readably = false) const override;
  virtual bool is_list() const override { return false; }

  virtual std::string inspect();

protected:
  std::vector<Value *> m_list{};
};

struct HashMapHash {
  std::size_t operator()(Value *key) const noexcept {
    return std::hash<std::string>{}(key->inspect());
  }
};
struct HashMapPred {
  constexpr bool operator()(Value *lhs, Value *rhs) const {
    return lhs == rhs; // FIXME
  }
};

class HashMapValue : public ListValue {
public:
  HashMapValue() {}
  virtual Type type() const override { return Type::HashMap; }
  virtual std::string inspect();

  virtual bool operator==(const Value *) const override;

  void set(Value *key, Value *val) { m_map[key] = val; }

  Value *get(Value *key) {
    auto search = m_map.find(key);
    if (search != m_map.end())
      return search->second;
    return nullptr;
  }

  auto begin() const { return m_map.begin(); }
  auto end() const { return m_map.end(); }
  size_t size() const { return m_map.size(); }

private:
  std::unordered_map<Value *, Value *, HashMapHash, HashMapPred> m_map;

protected:
  std::vector<Value *> m_list{};
};

class SymbolValue : public Value {
public:
  SymbolValue(std::string_view str) : m_str{str} {}
  // copy when call str
  std::string str() { return m_str; }
  bool matches(const char *str) const { return m_str == str; }
  virtual Type type() const override { return Type::Symbol; }
  virtual std::string inspect(bool) const override { return str(); }

private:
  std::string m_str;
};
#+end_src
#+begin_src c++ :tangle src/types.cpp
#include "types.hpp"

std::string ListValue::inspect() {
  std::string out = "(";
  for (auto *value : m_list) {
    out.append(value->inspect());
    out.append(" ");
  }
  if (m_list.size() > 0) {
    out[out.length() - 1] = ')';
  } else {
    out.append(")");
  }
  return out;
}

std::string VectorValue::inspect() {
  std::string out = "[";
  for (auto *value : m_list) {
    out.append(value->inspect());
    out.append(" ");
  }
  if (m_list.size() > 0) {
    out[out.length() - 1] = ']';
  } else {
    out.append("]");
  }
  return out;
}

std::string HashMapValue::inspect() {
  std::string out = "{";
  for (auto pair : m_map) {
    out.append(pair.first->inspect());
    out.append(" ");
    out.append(pair.second->inspect());
    out.append(" ");
  }
  if (m_map.size() > 0) {
    out[out.length() - 1] = ']';
  } else {
    out.append("}");
  }
  return out;
}
#+end_src
* Reader
#+begin_src c++ :tangle src/reader.hpp
#pragma once

#include <iostream>
#include <optional>
#include <string>
#include <string_view>
#include <vector>

#include "types.hpp"

class Tokenizer {
public:
  Tokenizer(std::string &input) : m_input{input} {}

  std::optional<std::string_view> next() {
    auto view = std::string_view(m_input);

    while (m_index < m_input.length()) {
      char c = m_input.at(m_index);

      switch (c) {
      case ' ':  // space
      case '\t': // tab
      case '\n': // new line
      case ',':  // comma
        ++m_index;
        break;
      case '~': {
        ++m_index;
        if (m_index + 1 < m_input.length() && m_input.at(m_index + 1) == '@') {
          ++m_index;
          return view.substr(m_index - 2, 2);
        }
        return view.substr(m_index - 1, 1);
      }
      case '[':  // open bracket
      case ']':  // closed bracket
      case '{':  // open curly
      case '}':  // closed curly
      case '(':  // open paren
      case ')':  // closed paren
      case '\'': // single quote
      case '`':  // backtick
      case '^':  // caret
      case '@':
        return view.substr(m_index++, 1);
      case '"': {
        size_t start = m_index;
        ++m_index;
        while (m_index < m_input.length()) {
          c = m_input.at(m_index);
          switch (c) {
          case '"':
            ++m_index;
            return view.substr(start, m_index - start);
          case '\\':
            ++m_index;
            break;
          }
          ++m_index;
        }
        // If no ending double quote to pair with first double quote,
        // return whatever is left & EOF.
        std::cout << "EOF\n";
        return view.substr(start, m_index - start);
      }
      case ';': {
        size_t start = m_index;
        while (m_index < m_input.length()) {
          c = m_input.at(m_index);
          if (c == '\n')
            break;
          ++m_index;
        }
        return view.substr(start, m_index - start);
      }
        // numbers here
      default: {
        return tokenize_symbol();
      }
      }
    }
    return {}; // return nothing if no token (a.k.a. why 'optional<string_view>
               // next()...' is necessary).
  }

private:
  std::string_view tokenize_symbol() {
    auto view = std::string_view(m_input);
    size_t start = m_index;
    bool done = false;
    char c;
    while (!done && m_index < m_input.length()) {
      c = m_input.at(m_index);
      switch (c) {
      case ' ':  // space
      case '\t': // tab
      case '\n': // new line
      case '[':
      case ']':
      case '{':
      case '}':
      case '(':
      case ')':
      case '\'':
      case '"':
      case '`':
      case ',':
      case ';':
        done = true;
        break;
      default:
        ++m_index;
      }
    }
    return view.substr(start, m_index - start);
  }
  std::string &m_input;
  size_t m_index{0};
};

class Reader {
public:
  Reader(std::vector<std::string_view> &tokens) : m_tokens{tokens} {}

  std::optional<std::string_view> next() {
    if (m_index < m_tokens.size())
      return m_tokens.at(m_index++);
    return {};
  }

  std::optional<std::string_view> peek() {
    if (m_index < m_tokens.size())
      return m_tokens.at(m_index);
    return {};
  }

private:
  std::vector<std::string_view> &m_tokens;
  size_t m_index{0};
};

std::vector<std::string_view> token(std::string &input);

Value *read_str(std::string &input);

Value *read_form(Reader &reader);

// Value *read_string(Reader &reader);

// Value *read_integer(Reader &reader);

Value *read_quoted_value(Reader &reader);

Value *read_with_meta(Reader &reader);

ListValue *read_list(Reader &reader);

ListValue *read_vector(Reader &reader);

HashMapValue *read_hash_map(Reader &reader);

Value *read_atom(Reader &reader);
#+end_src
#+begin_src c++ :tangle src/reader.cpp
#include "reader.hpp"

std::vector<std::string_view> tokenize(std::string &input) {
  Tokenizer tokenizer{input};
  std::vector<std::string_view> vector;
  while (auto token = tokenizer.next()) {
    vector.push_back(*token);
  }
  return vector;
}

Value *read_str(std::string &input) {
  auto tokens = tokenize(input);
  Reader reader{tokens};
  return read_form(reader);
}

Value *read_form(Reader &reader) {
  auto token = reader.peek();
  if (!token)
    return nullptr;
  switch (token.value()[0]) {
  case '(':
    return read_list(reader);
  case '[':
    return read_vector(reader);
  case '{':
    return read_hash_map(reader);
  case '\'':
  case '`':
  case '~':
  case '@':
    return read_quoted_value(reader);
  case '^':
    return read_with_meta(reader);
  default:
    return read_atom(reader);
  }
}

// Value *read_string(Reader &reader) { return nullptr; };  // FIXME

// Value *read_integer(Reader &reader) { return nullptr; }; // FIXME

Value *read_quoted_value(Reader &reader) {
  auto token = reader.peek();
  switch (token.value()[0]) {
  case '\'': {
    reader.next(); // consume quote
    auto list = new ListValue{};
    list->push(new SymbolValue{"quote"});
    list->push(read_form(reader));
    return list;
  }
  case '`': {
    reader.next(); // consume quote
    auto list = new ListValue{};
    list->push(new SymbolValue{"quasiquote"});
    list->push(read_form(reader));
    return list;
  }
  case '~': {
    if (token.value().length() > 1 && token.value()[1] == '@') {
      reader.next();
      auto list = new ListValue{};
      list->push(new SymbolValue{"splice-unquote"});
      list->push(read_form(reader));
      return list;
    } else {
      reader.next();
      auto list = new ListValue{};
      list->push(new SymbolValue{"unquote"});
      list->push(read_form(reader));
      return list;
    }
  }
  case '@': {
    reader.next();
    auto list = new ListValue{};
    list->push(new SymbolValue{"deref"});
    list->push(read_form(reader));
    return list;
  }
  default:
    std::cerr << "bad quote!\n";
    abort();
  }
}

Value *read_with_meta(Reader &reader) {
  reader.next(); // slurp '^' (caret)
  auto *list = new ListValue{};
  auto meta = read_form(reader);
  auto value = read_form(reader);
  list->push(value);
  list->push(meta);
  return list;
}

ListValue *read_list(Reader &reader) {
  reader.next(); // slurp '('
  auto *list = new ListValue{};
  // while we have tokens...
  while (auto token = reader.peek()) {
    if (*token == ")") {
      reader.next();
      return list;
    }
    list->push(read_form(reader));
  }
  std::cerr << "EOF\n";
  return list;
}

ListValue *read_vector(Reader &reader) {
  reader.next(); // slurp '['
  auto *vec = new VectorValue{};

  while (auto token = reader.peek()) {
    if (*token == "]") {
      reader.next();
      return vec;
    }
    vec->push(read_form(reader));
  }
  std::cerr << "EOF\n";
  return vec;
}

HashMapValue *read_hash_map(Reader &reader) {
  reader.next(); // slurp '{'
  auto *map = new HashMapValue{};

  while (auto token = reader.peek()) {
    if (*token == "}") {
      reader.next();
      return map;
    }
    auto key = read_form(reader);
    token = reader.peek();
    if (*token == "}") {
      std::cerr << "hash-map key without value!\n";
      reader.next();
      return map;
    }
    auto val = read_form(reader);

    map->set(key, val);
  }
  std::cerr << "EOF\n";
  return map;
}

Value *read_atom(Reader &reader) { return new SymbolValue{*reader.next()}; }
#+end_src
* Printer
#+begin_src c++ :tangle src/printer.hpp
#pragma once

#include <string>
#include "types.hpp"

std::string pr_str(Value *value, bool print_readably = false);
#+end_src

#+begin_src c++ :tangle src/printer.cpp
#include "printer.hpp"

std::string pr_str(Value *value) {
  return value->inspect();
};
#+end_src

* Step 0: A simple Read-Eval-Print-Loop (REPL)
#+begin_src c++ :tangle src/step0_repl.cpp
#include <iostream>
#include <string>
#include "linenoise.hpp"

std::string R(std::string s) { return s; }
std::string E(std::string s) { return s; }
std::string P(std::string s) { return s; }

std::string r(std::string s) {
  P(R(E(s)));
  return P(s);
}
int main() {
  const auto history_path = "history.txt";
  linenoise::LoadHistory(history_path);
  std::string s;
  for (;;) {
    auto quit = linenoise::Readline("user> ", s);
    linenoise::AddHistory(s.c_str());
    if (quit) { // ctrl+d to quit
      break;
    }
    std::cout << r(s) << "\n";
    std::cin.clear();
  }
  linenoise::SaveHistory(history_path);
  return 0;
}
#+end_src
* Step 1: Read, Print
#+begin_src c++ :tangle src/step1_read_print.cpp
#include <iostream>
#include <string>

#include "linenoise.hpp"
#include "printer.hpp"
#include "reader.hpp"
#include "types.hpp"

Value *READ(std::string s) { return read_str(s); }

Value *EVAL(Value *s) { return s; }

std::string PRINT(Value *s) { return pr_str(s, true); }

std::string rep(std::string s) {
  auto ast = READ(s);
  auto result = EVAL(ast);
  return PRINT(result);
  try {
    auto ast = READ(s);
    auto result = EVAL(ast);
    return PRINT(result);
  } catch (ExceptionValue *exception) {
    std::cerr << std::exception->message() << std::endl;
    return "";
  }
}

int main() {
  const auto history_path = "history.txt";
  linenoise::LoadHistory(history_path);

  std::string s;
  for (;;) {
    auto quit = linenoise::Readline("user> ", s);
    if (quit) { // ctrl+d to quit
      break;
    }
    std::cout << rep(s) << "\n";
    linenoise::AddHistory(s.c_str());
  }
  linenoise::SaveHistory(history_path);

  return 0;
}
#+end_src
